<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Tripgeo WebRTC Street-View Game</title>

<link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet">
<script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>

<style>
body{
  font-family:system-ui,Roboto,Arial,sans-serif;
  background:#f0f2f5;
  display:flex;justify-content:center;align-items:center;
  height:100vh;margin:0;text-align:center;
}
.container{
  background:#fff;padding:1.5rem;border-radius:12px;
  box-shadow:0 8px 30px rgba(0,0,0,.12);
  width:90%;max-width:900px;
}
h1{color:#00796b;margin-top:0}
#connectionPanel{
  display:flex;flex-wrap:wrap;gap:8px;justify-content:center;margin-bottom:1rem;
}
#connectionPanel input,#connectionPanel button{
  padding:.5rem .8rem;font-size:1rem;border:1px solid #ccc;border-radius:8px;
}
#connectionPanel button{
  background:#00796b;color:#fff;border:none;cursor:pointer;
}
#connectionPanel button:disabled{background:#9e9e9e}
#map{height:500px;width:100%;border-radius:8px;border:1px solid #ddd;margin-bottom:1rem;}
#streetViewContainer img{max-width:100%;border-radius:8px;border:1px solid #ccc;}
#gameStatus{margin-top:1rem;font-weight:500;color:#555;min-height:1.5rem}
@media(max-width:600px){#map{height:70vh}}
</style>
</head>

<body>
<div class="container">
  <h1>Street-View Guessing Game</h1>
  <div id="connectionPanel">
    <input id="roomIdInput" placeholder="Room ID">
    <input id="userNameInput" placeholder="Your Name">
    <button id="createRoomBtn" onclick="createSession()">Create Room</button>
    <button id="joinRoomBtn"   onclick="joinSession()">Join Room</button>
  </div>

  <div id="streetViewContainer"></div>
  <div id="map"></div>
  <p id="gameStatus">Create or join a room to start playing.</p>
</div>

<script>
class StreetViewGame {
  constructor(){
    this.roomId=null;
    this.userName=null;
    this.myUserId=Math.floor(Math.random()*10000)+1;
    this.isHost=false;
    this.map=null;
    this.myMarker=null;
    this.peerMarkers={};
    this.guesses={}; // { userId: { lng: X, lat: Y, userName: Z }, ... }
    this.currentProperty=null;
    this.signalRConnection=null;
    this.opponentUserId=null;
    this.correctMarker=null;
    this.myGuessSubmitted=false; // Flag to lock the guess

    this.initializeMap();
  }

  initializeMap(){
    this.map=new maplibregl.Map({
      container:'map',
      style:'https://tiles.openfreemap.org/styles/liberty',
      center:[0,0],
      zoom:2
    });
    // The first click is the final guess submission
    this.map.on('click', e => this.placeOrMoveMyMarker(e.lngLat.lng,e.lngLat.lat));
  }

  placeOrMoveMyMarker(lng,lat){
    const label=this.userName||'You';

    // Prevent marker placement/moving if guess is already submitted
    if (this.myGuessSubmitted) {
      this.updateStatus('Guess locked. Waiting for the opponent.');
      return; 
    }

    // Place the visual marker (only happens on the first click)
    if (!this.myMarker){
      this.myMarker=new maplibregl.Marker({color:'#00796b'})
        .setLngLat([lng,lat])
        .setPopup(new maplibregl.Popup({offset:12}).setText(label))
        .addTo(this.map);
      this.myMarker.togglePopup();
    } 
    // Since we are using a single-click model, no need for the 'else' block
    
    // Process and submit the guess immediately
    this.myGuessSubmitted=true;
    const guessData={
      userId:this.myUserId,
      userName:this.userName,
      lng:lng,
      lat:lat
    };
    
    // Store my guess locally
    this.guesses[this.myUserId]=guessData;
    
    // Send the guess submission to the opponent/host
    this.sendMapData('guess-submit',guessData);
    
    this.updateStatus('Guess submitted. Waiting for the opponent...');
    
    // Host check for game end (if opponent has already submitted)
    if(this.isHost&&Object.keys(this.guesses).length===2){
      this.calculateWinner();
    }
  }

  async connectToTripgeoHub(){
    if(this.signalRConnection) return;

    const hubUrl=`https://api.tripgeo.com/teamhub?userid=${this.myUserId}&teamid=shared_map_temp`;
    this.signalRConnection=new signalR.HubConnectionBuilder()
      .withUrl(hubUrl)
      .withAutomaticReconnect()
      .build();

    // Peer joined
    this.signalRConnection.on('WebRTCPeerJoined',(userName,userId)=>{
      if(userId!==this.myUserId){
        this.opponentUserId=userId;
        if(this.isHost){
          this.updateStatus(`${userName} joined. Loading street-view...`);
          this.loadRandomStreetView();
        } else {
          this.updateStatus(`${userName} joined. Waiting for street-view...`);
        }
      }
    });

    // Received street-view, guess, or results
    this.signalRConnection.on('WebRTCSignalingMessageReceived',async(fromUserId,messageType,messageData)=>{
      if(fromUserId!==this.myUserId){
        if(messageType==='street-view'){
          this.showStreetView(messageData);
        } else if (messageType === 'guess-submit') {
          this.handleGuessSubmission(messageData);
        } else if (messageType === 'game-over') {
          this.showResults(messageData);
        }
      }
    });

    await this.signalRConnection.start();
    this.updateStatus('Connected to Tripgeo hub.');
  }

  async sendStreetView(property){
    if(!this.opponentUserId) return;
    await this.signalRConnection.invoke('SendWebRTCSignalingMessage',this.opponentUserId.toString(),'street-view',property);
  }

  async loadRandomStreetView(){
    try{
      const res=await fetch('https://api.tripgeo.com/api/rentcast');
      const data=await res.json();
      const properties=data.filter(p=>p.streetView && p.streetView.hasStreetView);
      if(!properties.length){ this.updateStatus('No street-view available'); return; }

      const property=properties[Math.floor(Math.random()*properties.length)];
      this.currentProperty=property;
      this.showStreetView(property);

      if(this.isHost) await this.sendStreetView(property);
    }catch(err){
      console.error(err);
      this.updateStatus('Failed to load street-view data.');
    }
  }

  showStreetView(property){
    this.currentProperty=property;
    const pano=property.streetView;
    const imgUrl=`https://api.tripgeo.com/api/StreetViewImage/${pano.panoId}_${pano.direction}`;
    document.getElementById('streetViewContainer').innerHTML=`<img src="${imgUrl}" alt="Street View">`;
    this.updateStatus('Look at the street-view above and click on the map to place your guess.');
    
    // Reset state for new round
    this.guesses={};
    this.myGuessSubmitted=false;
    if(this.myMarker){
      this.myMarker.remove();
      this.myMarker=null;
    }
    if(this.correctMarker){
      this.correctMarker.remove();
      this.correctMarker=null;
    }
    Object.values(this.peerMarkers).forEach(m=>m.remove());
    this.peerMarkers={};
  }

  sendMapData(type,data){
    if(!this.signalRConnection || !this.opponentUserId) return;
    this.signalRConnection.invoke('SendWebRTCSignalingMessage',this.opponentUserId.toString(),type,data).catch(console.error);
  }

  handleGuessSubmission(data) {
    // Place the opponent's marker and store their submission
    if (data.userId !== this.myUserId) {
      const popup = new maplibregl.Popup({ offset: 12 }).setText(data.userName || 'Peer');
      this.peerMarkers[data.userId] = new maplibregl.Marker({ color: '#d9534f' })
        .setLngLat([data.lng, data.lat])
        .setPopup(popup)
        .addTo(this.map);
      this.peerMarkers[data.userId].togglePopup();

      this.guesses[data.userId] = { lng: data.lng, lat: data.lat, userName: data.userName };
    }
    
    this.updateStatus(`${data.userName} has submitted their guess. Waiting for ${Object.keys(this.guesses).length === 1 ? 'you' : 'host calculation'}...`);
    
    // Check if both players have submitted (HOST ONLY)
    if (this.isHost && Object.keys(this.guesses).length === 2) {
      this.calculateWinner();
    }
  }

  calculateWinner() {
    if (!this.currentProperty || Object.keys(this.guesses).length < 2) return;
    
    const { panoramaLng: correctLng, panoramaLat: correctLat } = this.currentProperty.streetView;
    const players = Object.keys(this.guesses);
    
    let winnerId = null;
    let minDistance = Infinity;
    const results = {};
    
    players.forEach(userId => {
      const guess = this.guesses[userId];
      const distance = this.calculateDistance(correctLat, correctLng, guess.lat, guess.lng);
      
      results[userId] = { distance: distance, userName: guess.userName };
      
      if (distance < minDistance) {
        minDistance = distance;
        winnerId = userId;
      }
    });

    results.correctLocation = { lng: correctLng, lat: correctLat };
    results.winnerId = winnerId;
    
    // Send game over message and show results
    this.sendMapData('game-over', results);
    this.showResults(results);
  }

  showResults(results) {
    const { correctLocation: { lng: correctLng, lat: correctLat }, winnerId } = results;
    
    // Add the correct location marker
    this.correctMarker = new maplibregl.Marker({ color: '#00cc00' }) // Green
      .setLngLat([correctLng, correctLat])
      .setPopup(new maplibregl.Popup({ offset: 12 }).setText('Correct Location'))
      .addTo(this.map);
    this.correctMarker.togglePopup();
    
    // Center the map
    this.map.flyTo({ center: [correctLng, correctLat], zoom: 6 });
    
    const winner = results[winnerId].userName;
    let statusMessage = `Game Over! The correct location is marked in **green**. **${winner}** wins!`;
    
    // Append individual results
    Object.keys(results).forEach(userId => {
        if (userId !== 'correctLocation' && userId !== 'winnerId') {
            const distanceKm = (results[userId].distance / 1000).toFixed(2);
            statusMessage += ` | **${results[userId].userName}** was **${distanceKm} km** away.`;
        }
    });
    
    this.updateStatus(statusMessage);
  }

  // Haversine formula (Distance in meters)
  calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3; // metres
    const φ1 = lat1 * Math.PI / 180;
    const φ2 = lat2 * Math.PI / 180;
    const Δφ = (lat2 - lat1) * Math.PI / 180;
    const Δλ = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) *
      Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    const distance = R * c; 
    return distance;
  }
  
  updateStatus(msg) { document.getElementById('gameStatus').innerHTML=msg; }
}

const game=new StreetViewGame();

async function createSession(){
  const room=document.getElementById('roomIdInput').value.trim();
  const name=document.getElementById('userNameInput').value.trim();
  if(!room||!name){alert('Enter room and name');return;}
  game.roomId=room;
  game.userName=name;
  game.isHost=true;
  await game.connectToTripgeoHub();
  await game.signalRConnection.invoke('JoinWebRTCSession',`map_${room}`,game.myUserId);
  game.updateStatus(`Room "${room}" created. Waiting for players...`);
  document.getElementById('createRoomBtn').disabled=true;
  document.getElementById('joinRoomBtn').disabled=true;
}

async function joinSession(){
  const room=document.getElementById('roomIdInput').value.trim();
  const name=document.getElementById('userNameInput').value.trim();
  if(!room||!name){alert('Enter room and name');return;}
  game.roomId=room;
  game.userName=name;
  game.isHost=false;
  await game.connectToTripgeoHub();
  await game.signalRConnection.invoke('JoinWebRTCSession',`map_${room}`,game.myUserId);
  game.updateStatus(`Joining room "${room}"...`);
  document.getElementById('createRoomBtn').disabled=true;
  document.getElementById('joinRoomBtn').disabled=true;
}
</script>
</body>
</html>
